# Kodestandarter

Kodestandarter sikrer konsistens, læsbarhed og vedligeholdelighed i softwareprojekter. Dette kapitel gennemgår vigtige principper for at skrive klar og effektiv C#-kode, herunder navngivning, formatering, og anvendelse af metoder og klasser.

## Navngivningskonventioner

- **Klasser, Interfaces og Felter**: Brug PascalCase.
    - Eksempel: `public class Employee`, `public interface IEmployee`, `public int EmployeeAge`.
- **Metoder**: Brug PascalCase.
    - Eksempel: `public void CalculateSalary()`.
- **Variabler**: Brug camelCase.
    - Eksempel: `int employeeAge`.
- **Konstanter**: Brug UPPER_CASE med underscore.
    - Eksempel: `const int MAX_SALARY = 100000;`.

## Formatering

- **Indrykning**: Brug fire mellemrum for at skabe ensartethed.
- **Linjelængde**: Hold linjerne under 80-100 tegn.
- **Tuborgklammer `{}`**:
    - Placér altid åbningsklammer på linjen efter:
        
        ```csharp
        if (condition)
        {
            // code
        }
        ```

## Kommentarer

- Brug **inline-kommentarer** til at forklare komplekse linjer:
   ```csharp
   int age = CalculateAge(birthYear); // Beregner alder ud fra fødselsår
   ```

- Brug **XML-dokumentation** til public medlemmer:

   ```csharp
   /// <summary>
   /// Beregner alderen for en medarbejder.
   /// </summary>
   /// <param name="birthYear">Fødselsåret.</param>
   /// <returns>Alderen.</returns>
   public int CalculateAge(int birthYear)
   {
       return DateTime.Now.Year - birthYear;
   }
   ```

## Brug af metoder

- Hold metoder korte og fokuserede med ét formål (Single Responsibility Principle).
    - Hellere flere metoder, end en rigtig lang metode.
- Navngiv metoder efter deres handlinger:
    
    ```csharp
    public void PrintReport();
    ```

## Brug af klasser og interfaces

- Følg principperne for objektorienteret programmering:
    - **Encapsulation**: Skjul implementeringsdetaljer ved at bruge private felter og offentlige metoder.
    - **Inheritance**: Genbrug kode gennem arv, men undgå overbrug.
    - **Polymorphism**: Brug interfaces til at understøtte fleksibilitet.

## Fejlhåndtering

- Brug undtagelser til at signalere fejl og log dem konsekvent:
    
    ```csharp
    try
    {
        // kode
    }
    catch (Exception ex)
    {
        Console.WriteLine($"Fejl: {ex.Message}");
    }
    ```

## Performanceoptimering

Meget af vores performance har vi gået i gennem fx i [[7. Loops og iterationer]]. Her kan vi opsummere de vigtige dele

### Vælg den rigtige datastruktur

Valg af den rette datastruktur er afgørende for effektiv databehandling og performance. Her er nogle almindelige datastrukturer og deres anvendelser:

1. **Arrays**
    
    - Bruges til faste samlinger af elementer, hvor størrelsen er kendt på forhånd.
    - Fordel: Hurtig adgang ved indeks.
    - Ulempe: Størrelsen kan ikke ændres.
    
    ```csharp
    int[] numbers = { 1, 2, 3, 4, 5 };
    ```
    
2. **Lists (List<T>)**
    - Ideel til dynamiske samlinger, hvor størrelsen kan ændres løbende.
    - Fordel: Nem tilføjelse og fjernelse af elementer.
    - Ulempe: Kan være langsommere end arrays ved sekventiel adgang.
    
    ```csharp
    var numbers = new List<int> { 1, 2, 3 };
    numbers.Add(4);
    ```

3. **Dictionaries (Dictionary<TKey, TValue>)**
    - Perfekt til nøgle-værdi-opslag.
    - Fordel: Hurtig opslagstid (O(1)).
    - Ulempe: Mere hukommelseskrævende end lister og arrays.
    
    ```csharp
    var phoneBook = new Dictionary<string, string>
    {
        { "Alice", "1234" },
        { "Bob", "5678" }
    };
    ```

4. **Queues og Stacks**
    - Bruges til specialiserede adgangsmønstre som FIFO (First In, First Out) og LIFO (Last In, First Out).
    - Queue: Velegnet til køhåndtering som jobkøer.
        
        ```csharp
        var queue = new Queue<int>();
        queue.Enqueue(1);
        int first = queue.Dequeue();
        ```
        
    - Stack: Velegnet til kaldestakke eller undo-operationer.
        
        ```csharp
        var stack = new Stack<int>();
        stack.Push(1);
        int last = stack.Pop();
        ```

5. **HashSet<T>**
    - Anvendes til samlinger af unikke elementer.
    - Fordel: Hurtige tjek for, om et element findes (O(1)).
    - Ulempe: Ingen garanteret rækkefølge.
    
    ```csharp
    var uniqueNumbers = new HashSet<int> { 1, 2, 3 };
    uniqueNumbers.Add(2); // Ignoreres, da 2 allerede findes.
    ```

### Praktiske tips til valg af datastruktur

- Hvis **størrelsen er fast**: Brug arrays.
- Hvis **orden er vigtig**: Brug List eller Queue.
- Hvis **unikhed er nødvendig**: Brug HashSet.
- Hvis **opslag er hyppige**: Brug Dictionary.
- Hvis **stakken skal tjekkes baglæns**: Brug Stack.
- Undgå overflødige beregninger.

### Brug det rette loop til opgaven

1. **For-loop**
    - Velegnet, når antallet af iterationer er kendt på forhånd.
    - Fordel: Giver præcis kontrol over indekser og iterationer.
    
    ```csharp
    for (int i = 0; i < array.Length; i++)
    {
        Console.WriteLine(array[i]);
    }
    ```

2. **While-loop**
    - Bruges, når antallet af iterationer afhænger af en dynamisk betingelse.
    - Fordel: Fleksibelt og kan tilpasses komplekse betingelser.
    
    ```csharp
    int i = 0;
    while (i < array.Length)
    {
        Console.WriteLine(array[i]);
        i++;
    }
    ```

3. **Do-while-loop**
    - Velegnet, når mindst én iteration skal udføres, uanset betingelsen.
    
    ```csharp
    int i = 0;
    do
    {
        Console.WriteLine(array[i]);
        i++;
    } while (i < array.Length);
    ```

4. **Foreach-loop**
    - Ideel til iteration over samlinger som arrays, lister, og dictionaries.
    - Fordel: Forenkler koden og reducerer fejl ved håndtering af indekser.
    
    ```csharp
    foreach (var item in array)
    {
        Console.WriteLine(item);
    }
    ```

### Optimer loop-effektivitet

1. **Reducer antallet af iterationer**
    - Flyt beregninger uden for løkken, når muligt.
    
    ```csharp
    // Ineffektiv
    for (int i = 0; i < list.Count; i++)
    {
        if (list.Count > 100) { /* ... */ }
    }
    
    // Optimeret
    int count = list.Count;
    for (int i = 0; i < count; i++)
    {
        if (count > 100) { /* ... */ }
    }
    ```

2. **Brug break og continue klogt**
    - `break`: Stop loopet tidligt, hvis yderligere iterationer er unødvendige.
    - `continue`: Spring unødvendige iterationer over.
    
    ```csharp
    for (int i = 0; i < array.Length; i++)
    {
        if (array[i] < 0) continue; // Spring negative værdier over
        if (array[i] == 100) break; // Stop ved 100
        Console.WriteLine(array[i]);
    }
    ```

3. **Iteratorer med store datamængder**
    - Overvej streamingmetoder som LINQ, når det er muligt.
    
    ```csharp
    var results = array.Where(x => x > 10).Select(x => x * 2);
    foreach (var result in results)
    {
        Console.WriteLine(result);
    }
    ```

## Automatisk formatering

- Anvend værktøjer som **Prettier** for at sikre ensartet stil.
- Brug Visual Studio til automatisk indrykning og formatering.

## Opsummering

Ved at følge kodestandarter kan du forbedre læsbarheden og robustheden af din C#-kode. Det hjælper ikke kun med samarbejde i teams, men gør også debugging og vedligeholdelse lettere i fremtiden.